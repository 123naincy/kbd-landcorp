import{k as b,l,n as v,o as y,r as i,j as x,p as A}from"./index-Bk1ELBaw.js";function E(t){t.values.forEach(r=>r.stop())}function c(t,r){[...r].reverse().forEach(e=>{const n=t.getVariant(e);n&&l(t,n),t.variantChildren&&t.variantChildren.forEach(o=>{c(o,r)})})}function g(t,r){if(Array.isArray(r))return c(t,r);if(typeof r=="string")return c(t,[r]);l(t,r)}function C(){const t=new Set,r={subscribe(s){return t.add(s),()=>void t.delete(s)},start(s,e){const n=[];return t.forEach(o=>{n.push(b(o,s,{transitionOverride:e}))}),Promise.all(n)},set(s){return t.forEach(e=>{g(e,s)})},stop(){t.forEach(s=>{E(s)})},mount(){return()=>{r.stop()}}};return r}function V(){const t=v(C);return y(t.mount,[]),t}const R=V,j={hidden:{opacity:0,y:24},visible:{opacity:1,y:0,transition:{duration:.6,ease:"easeOut"}}};function w({as:t="div",delay:r=0,className:s,variants:e=j,children:n}){const o=i.useRef(null),a=R(),[u,p]=i.useState(!1);return i.useEffect(()=>{const f=o.current;if(!f)return;const d=new IntersectionObserver(h=>{h.forEach(m=>{m.isIntersecting&&!u&&(a.start("visible"),p(!0))})},{rootMargin:"0px 0px -10% 0px",threshold:.1});return d.observe(f),()=>d.disconnect()},[a,u]),x.jsx(A.div,{ref:o,initial:"hidden",animate:a,variants:e,transition:{delay:r/1e3},className:s,as:t,children:n})}export{w as R};
